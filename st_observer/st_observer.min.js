class st_observer{static#e=new Map;constructor(e={}){const t=Object.assign({selector:null,root:null,rootMargin:"0px",threshold:0,before_init:()=>{},on_init:()=>{}},e);if(!t.selector)throw new Error("st_observer: selector required");const s="string"==typeof t.selector?t.selector:Symbol("selector");if(st_observer.#e.has(s))return this._internal=st_observer.#e.get(s),this;const r={key:s,selector:t.selector,options:{root:t.root,rootMargin:t.rootMargin,threshold:t.threshold},observer:null,callbacks:new WeakMap,elements:new Set,_connected:!1,crossRules:new Map};t.before_init();const o=()=>({on_show:new Set,once_show:new Set,while_show:new Set,on_hide:new Set,once_hide:new Set,while_hide:new Set,_once_shown:!1,_once_hidden:!1,_wasIntersecting:!1}),n=(e,...t)=>{try{e(...t)}catch(e){console.error(e)}},i=(e,t)=>!(e.right<=t.left||e.left>=t.right||e.bottom<=t.top||e.top>=t.bottom),c=e=>e?"string"==typeof e?Array.from(document.querySelectorAll(e)):e instanceof Element?[e]:NodeList.prototype.isPrototypeOf(e)||Array.isArray(e)?Array.from(e):[]:"string"==typeof r.selector?Array.from(document.querySelectorAll(r.selector)):r.selector instanceof Element?[r.selector]:NodeList.prototype.isPrototypeOf(r.selector)||Array.isArray(r.selector)?Array.from(r.selector):[],l=e=>{const t=r.crossRules.get(e);if(!t||!t.length)return;if(!document.contains(e))return;const s=e.getBoundingClientRect();for(const r of t)for(const t of r.goals){if(!document.contains(t)){r._wasCrossing.set(t,!1);continue}const o=t.getBoundingClientRect(),c=i(s,o);c&&r.while_cross.forEach(s=>n(s,{target:e,goal:t},e,t));!!!r._wasCrossing.get(t)&&c&&r.on_cross.forEach(s=>n(s,{target:e,goal:t},e,t)),c&&!r._once_done.has(t)&&(r.once_cross.forEach(s=>n(s,{target:e,goal:t},e,t)),r._once_done.add(t)),r._wasCrossing.set(t,!!c)}},a=()=>{for(const e of Array.from(r.crossRules.keys()))if(document.contains(e))try{l(e)}catch(e){console.error(e)}};this._internal=r,this._createCbObj=o,this._resolveTargets=c,this._createCrossRule=e=>({goals:new Set(e),on_cross:new Set,once_cross:new Set,while_cross:new Set,_once_done:new Set,_wasCrossing:new Map}),this._checkCrossForTarget=l,this._runAllCrossChecks=a,this._makeIoCallback=()=>e=>{for(const t of e){const e=t.target;let s=r.callbacks.get(e);s||(s=o(),r.callbacks.set(e,s)),t.isIntersecting?(s.while_show.forEach(s=>n(s,t,e)),s._wasIntersecting||s.on_show.forEach(s=>n(s,t,e)),s._once_shown||(s._once_shown=!0,s.once_show.forEach(s=>n(s,t,e))),s._wasIntersecting=!0):(s.while_hide.forEach(s=>n(s,t,e)),s._wasIntersecting&&s.on_hide.forEach(s=>n(s,t,e)),s._once_hidden||(s._once_hidden=!0,s.once_hide.forEach(s=>n(s,t,e))),s._wasIntersecting=!1)}a()};const h=c();for(const e of h)r.elements.add(e),t.on_init(e),r.callbacks.get(e)||r.callbacks.set(e,o());st_observer.#e.set(s,r),this.connect()}enableAutoCrossChecks(e={}){const t=Object.assign({strategy:"all",watchScrollAncestors:!0,watchResize:!0,rAFWhileAnimating:!1},e);if(this._autoChecks)return this._autoChecks.cfg=t,this;const s=this._internal,r=this;let o=!1;const n=e=>{const t=new Set;let s=e.parentNode;for(;s&&s!==document;){if(s instanceof HTMLElement){const e=getComputedStyle(s),r=e.overflow+e.overflowX+e.overflowY;/(auto|scroll|overlay)/.test(r)&&t.add(s)}s=s.parentNode}return t.add(window),Array.from(t)},i=()=>{o||(o=!0,requestAnimationFrame(()=>{o=!1,("all"===t.strategy||"entryOnly"===t.strategy)&&r._runAllCrossChecks()}))},c=new Set;if(t.watchScrollAncestors)for(const e of Array.from(s.elements)){n(e).forEach(e=>{c.has(e)||(e.addEventListener("scroll",i,{passive:!0}),c.add(e))})}else window.addEventListener("scroll",i,{passive:!0}),c.add(window);t.watchResize&&window.addEventListener("resize",i,{passive:!0});let l=null;const a=()=>{r._runAllCrossChecks(),l=requestAnimationFrame(a)};return this._autoChecks={cfg:t,scrollTargets:c,onScrollOrResize:i,rafId:l,startRaf:()=>{l||a()},stopRaf:()=>{l&&(cancelAnimationFrame(l),l=null)}},this}disableAutoCrossChecks(){if(!this._autoChecks)return this;const e=this._autoChecks;e.scrollTargets.forEach(t=>{try{t.removeEventListener("scroll",e.onScrollOrResize)}catch(e){}});try{window.removeEventListener("resize",e.onScrollOrResize)}catch(e){}return e.stopRaf(),this._autoChecks=null,this}_register(e,t,s){if("function"!=typeof t)return this;const r=this._internal,o=this._resolveTargets(s);for(const s of o){let o=r.callbacks.get(s);if(o||(o=this._createCbObj(),r.callbacks.set(s,o)),o[e].add(t),!r.elements.has(s)&&(r.elements.add(s),r._connected&&r.observer))try{r.observer.observe(s)}catch(e){}}return this}on_show(e,t){return this._register("on_show",e,t)}while_show(e,t){return this._register("while_show",e,t)}once_show(e,t){return this._register("once_show",e,t)}on_hide(e,t){return this._register("on_hide",e,t)}while_hide(e,t){return this._register("while_hide",e,t)}once_hide(e,t){return this._register("once_hide",e,t)}observe(e){const t=this._resolveTargets(e);for(const e of t)if(this._internal.callbacks.get(e)||this._internal.callbacks.set(e,this._createCbObj()),this._internal.elements.add(e),this._internal._connected&&this._internal.observer)try{this._internal.observer.observe(e)}catch(e){}return this}unobserve(e){const t=this._resolveTargets(e);for(const e of t){try{this._internal.observer&&this._internal.observer.unobserve(e)}catch(e){}this._internal.callbacks.delete(e),this._internal.elements.delete(e)}return this}disconnect(){try{this._internal.observer&&this._internal.observer.disconnect()}catch(e){}return this._internal.observer=null,this._internal._connected=!1,this}connect(e={}){if(this._internal._connected)return this;if(void 0!==e.root&&(this._internal.options.root=e.root),void 0!==e.rootMargin&&(this._internal.options.rootMargin=e.rootMargin),void 0!==e.threshold&&(this._internal.options.threshold=e.threshold),this._internal.observer=new IntersectionObserver(this._makeIoCallback(),this._internal.options),e.resetFlags)for(const e of Array.from(this._internal.elements)){const t=this._internal.callbacks.get(e);t&&(t._once_shown=!1,t._once_hidden=!1,t._wasIntersecting=!1)}for(const e of Array.from(this._internal.elements))try{this._internal.observer.observe(e)}catch(e){}return this._internal._connected=!0,this}reconnect(e={}){return this.connect(e)}resetOnceFlags(e){const t=e?this._resolveTargets(e):Array.from(this._internal.elements);for(const e of t){const t=this._internal.callbacks.get(e);t&&(t._once_shown=!1,t._once_hidden=!1,t._wasIntersecting=!1)}return this}isConnected(){return!!this._internal._connected}getObservedElements(){return Array.from(this._internal.elements)}_registerCross(e,t,s,r){if("function"!=typeof t)return this;const o=this._internal;void 0===r&&("string"==typeof s||s instanceof Element||NodeList.prototype.isPrototypeOf(s)||Array.isArray(s))&&(r=s,s=void 0);const n=this._resolveTargets(s),i=this._resolveTargets(r);if(!i.length)return console.warn("st_observer: cross registration no goals"),this;for(const s of n){o.callbacks.get(s)||o.callbacks.set(s,this._createCbObj()),o.elements.add(s);let r=o.crossRules.get(s);r||(r=[],o.crossRules.set(s,r));let n=r.find(e=>{if(e.goals.size!==i.length)return!1;for(const t of i)if(!e.goals.has(t))return!1;return!0});n||(n=this._createCrossRule(i),r.push(n)),n[e].add(t);for(const e of i)o.elements.add(e)}return this._runAllCrossChecks(),this}on_cross(e,t,s){return this._registerCross("on_cross",e,t,s)}once_cross(e,t,s){return this._registerCross("once_cross",e,t,s)}while_cross(e,t,s){return this._registerCross("while_cross",e,t,s)}resetCrossOnceFlags(e,t){const s=this._internal,r=e?this._resolveTargets(e):Array.from(s.crossRules.keys()),o=t?this._resolveTargets(t):null;for(const e of r){const t=s.crossRules.get(e);if(t)for(const e of t)if(o)for(const t of o)e._once_done.delete(t);else e._once_done.clear()}return this}}